// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  role      Role     @default(ADMIN)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  addedById  String?
  addedBy    User?   @relation("UserAddedBy", fields: [addedById], references: [id])
  addedUsers User[]  @relation("UserAddedBy")

  ordersOpened         Order[]        @relation("OrderOrderedBy")
  checksOpened         Check[]        @relation("CheckOpenedBy")
  checksClosed         Check[]        @relation("CheckClosedBy")
  paymentsMade         Payment[]
  voidRecords          VoidRecord[]
  openedDailySummaries DailySummary[] @relation("DailySummaryOpenedBy")
  closedDailySummaries DailySummary[] @relation("DailySummaryClosedBy")

  inventoryTransactions InventoryTransaction[]
}

enum Role {
  OWNER
  ADMIN
  MESERO
  COCINERO
  CAJERO
  BARISTA
}

model Table {
  id        String      @id @default(cuid())
  number    Int         @unique
  name      String?
  capacity  Int
  status    TableStatus @default(AVAILABLE)
  deletedAt DateTime?

  mergedIntoId String?
  mergedInto   Table?  @relation("MergedTable", fields: [mergedIntoId], references: [id])
  mergedTables Table[] @relation("MergedTable")

  currentCheckId String?
  currentCheck   Check?  @relation(fields: [currentCheckId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  DIRTY
}

model Category {
  id           String     @id @default(cuid())
  name         String
  displayOrder Int        @default(0)
  isActive     Boolean    @default(true)
  items        MenuItem[]
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

enum Station {
  KITCHEN
  BAR
}

model MenuItem {
  id          String      @id @default(cuid())
  name        String
  description String?
  price       Decimal
  isAvailable Boolean     @default(true)
  prepTimeMin Int?
  station     Station
  categoryId  String
  category    Category    @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  orderItems  OrderItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  recipeItems RecipeItem[]
}

model Check {
  id     String      @id @default(cuid())
  status CheckStatus @default(OPEN)

  tableIds String
  notes    String?

  openedAt DateTime  @default(now())
  closedAt DateTime?

  subtotal Decimal @default(0)
  tax      Decimal @default(0)
  discount Decimal @default(0)
  total    Decimal @default(0)

  openedById String
  openedBy   User    @relation("CheckOpenedBy", fields: [openedById], references: [id])
  closedById String?
  closedBy   User?   @relation("CheckClosedBy", fields: [closedById], references: [id])

  orders   Order[]
  payments Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  tables    Table[]
}

enum CheckStatus {
  OPEN
  CLOSED
  VOIDED
}

model Order {
  id          String      @id @default(cuid())
  status      OrderStatus @default(PENDING)
  checkId     String
  check       Check       @relation(fields: [checkId], references: [id], onDelete: Cascade)
  orderedById String
  orderedBy   User        @relation("OrderOrderedBy", fields: [orderedById], references: [id])

  sentToKitchenAt DateTime?
  sentToBarAt     DateTime?
  completedAt     DateTime?

  items     OrderItem[]
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
}

enum OrderItemStatus {
  PENDING
  PREPARING
  READY
  SERVED
  VOIDED
}

enum OrderStatus {
  PENDING
  SENT
  PREPARING
  READY
  COMPLETED
  CANCELLED
}

model OrderItem {
  id           String          @id @default(cuid())
  orderId      String
  order        Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  menuItemId   String
  menuItem     MenuItem        @relation(fields: [menuItemId], references: [id])
  quantity     Int             @default(1)
  notes        String?
  priceAtOrder Decimal
  status       OrderItemStatus @default(PENDING)

  modifiers Json?

  createdAt DateTime @default(now())
}

model Payment {
  id      String        @id @default(cuid())
  checkId String
  check   Check         @relation(fields: [checkId], references: [id])
  method  PaymentMethod
  amount  Decimal

  cashAmount Decimal?
  yapeAmount Decimal?

  status    PaymentStatus @default(COMPLETED)
  createdAt DateTime      @default(now())

  userId String?
  user   User?   @relation(fields: [userId], references: [id])
}

enum PaymentMethod {
  CASH
  MOBILE_PAY
  MIXED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  REFUNDED
  FAILED
}

model VoidRecord {
  id         String     @id @default(cuid())
  target     VoidTarget
  targetId   String
  reason     String
  voidedById String
  voidedBy   User       @relation(fields: [voidedById], references: [id])
  note       String?
  createdAt  DateTime   @default(now())
}

enum VoidTarget {
  ORDER
  ORDER_ITEM
  CHECK
}

model InventoryItem {
  id                String   @id @default(cuid())
  name              String
  currentQuantity   Float    @default(0) // Renamed for clarity
  unit              String // Base unit: "kg", "L", "units", etc.
  category          String?
  lowStockThreshold Float? // Alert when below this value
  costPerUnit       Decimal? // For COGS calculations
  notes             String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  recipeItems  RecipeItem[]
  transactions InventoryTransaction[]
}

model PaymentSummary {
  id        String   @id @default(cuid())
  date      DateTime @db.Date
  cashTotal Decimal  @default(0)
  yapeTotal Decimal  @default(0)
  total     Decimal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([date])
  @@index([date])
}

model DailySummary {
  id           String             @id @default(cuid())
  date         DateTime
  startingCash Decimal
  totalCash    Decimal
  totalYape    Decimal
  endingCash   Decimal
  status       DailySummaryStatus @default(OPEN)
  openedById   String
  openedBy     User               @relation("DailySummaryOpenedBy", fields: [openedById], references: [id])
  closedById   String?
  closedBy     User?              @relation("DailySummaryClosedBy", fields: [closedById], references: [id])
  openedAt     DateTime           @default(now())
  closedAt     DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@unique([date])
  @@index([date])
}

enum DailySummaryStatus {
  OPEN
  CLOSED
}

model RecipeItem {
  id              String        @id @default(cuid())
  menuItemId      String
  menuItem        MenuItem      @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])

  quantityRequired Float // Amount needed per 1 unit of menuItem
  unit             String // Unit for this line (should match inventoryItem.unit)
  isOptional       Boolean @default(false) // For modifiers/add-ons
  note             String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([menuItemId, inventoryItemId])
  @@index([inventoryItemId])
}

model InventoryTransaction {
  id              String        @id @default(cuid())
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])

  type           TransactionType
  quantityChange Float // Positive = restock, Negative = deduction
  referenceModel String? // "OrderItem", "ManualAdjustment", etc.
  referenceId    String? // ID of the related record
  reason         String?

  performedById String?
  performedBy   User?   @relation(fields: [performedById], references: [id])

  createdAt DateTime @default(now())

  @@index([inventoryItemId, createdAt])
}

enum TransactionType {
  SALE_DEDUCTION
  RESTOCK
  MANUAL_ADJUSTMENT
  WASTE
  RETURN
}
